class GameFilled 
{
	static int x1; //координаты начала поля 
	static int y1;
	static int x2;//конца
	static int y2;
	static String scoreString;
	field int score;
	field Array isFusionCells;
	field Array cells; // двумерный массив
	field int gridSize; // размер сетки
	field boolean isWin;

	constructor GameFilled new(int size) 
	{
		let score = 0;
		let gridSize = size;
		let isWin = false;
		let scoreString = "Score:";
		let x1 = 136;
		let y1 = 8;
		let x2 = (136 + 240);
		let y2 = (8 + 240);

		//инициализируется двумерный массив int-ов соответствующий игровому полю
		let cells = InitializationArrayOfArray(0);

		//инициализируется двумерный массив bool-ов соответствующий игровому полю
		let isFusionCells = InitializationArrayOfArray(1);

		// рисуется игрове поле
		do Screen.setColor(true);
		do draw();

		return this;
	}

	method void dispose() 
	{
		var int i;
		var Array tempArr;

		let i = 0;
		while (i < gridSize)
		{
			let tempArr = cells[i];
			do tempArr.dispose();
			let i = i + 1;
		}
		do cells.dispose();
		do scoreString.dispose();
		do Memory.deAlloc(this);
		return;
	}

	method int getWin() 
	{
        return isWin;
	}

	method int getSize()
	{
        return gridSize;
    }

	method int getScore() 
	{
        return score;
	}

	method void setScore(int bonus)
	{
		let score = score + bonus;
		do Output.moveCursor(1, 1);
		do Output.printString(scoreString);
		do Output.printInt(score);
		return;
	}

	/*Рисует игровую сетку */
	method void draw() 
	{
		var int tileSize, i, j;
		var Array tempArr;

		let tileSize = 240 / gridSize; // Размер плитки в зависимости от количества плиток

		// Вертикальные линии
		let i = 0;
		while (i < (gridSize + 1)) 
		{
			do Screen.drawLine(x1 + (i * tileSize), y1, x1 + (i * tileSize), y2); 
			let i = i + 1;
		}

		// Горизонтальные линии
		let j = 0;
		while (j < (gridSize + 1)) 
		{
			do Screen.drawLine(x1, y1 + (j * tileSize), x2, y1 + (j * tileSize)); 
			let j = j + 1;
		}

		//начальные ячейки
		let tempArr = cells[0];

		do DrawerNum.drawNum(4, (x1 + 5), (y1 + 5), gridSize);
		let tempArr[0] = 4;
		do setScore(4);

		do DrawerNum.drawNum(2, (x1 + 5)+ tileSize, (y1 + 5), gridSize);
		let tempArr[1] = 2;
		do setScore(2);

		return;
	}
	
	method Array InitializationArrayOfArray(int defult)
	{
		var int i, j;
		var Array tempArr, array;
		
		let array = Array.new(gridSize);
		let i = 0;
		let j = 0;
		while (i < gridSize)
		{
			let array[i] = Array.new(gridSize);
			let tempArr = array[i];
			while (j < gridSize)
			{
				let tempArr[j] = defult;
				let j = j + 1;
			}
			let j = 0;
			let i = i + 1;
		}

		return array;
	}

	method Array FillArrayOfArray(Array array, boolean defult)
	{
		var int i, j;
		var Array tempArr;

		let i = 0;
		let j = 0;
		while (i < gridSize)
		{
			let tempArr = array[i];
			while (j < gridSize)
			{
				let tempArr[j] = defult;
				let j = j + 1;
			}
			let j = 0;
			let i = i + 1;
		}

		return array;
	}


	method void moveInDirection(int dx, int dy)
	{
		var Array tempArr, tempArr1, boolArr, boolArr1;
		var int i, j, p, ni, nj;
		var boolean addNewTile;
		var int di, dj;

		do FillArrayOfArray(isFusionCells, true);
		let p = gridSize - 1;

		// Вычисляем начальные направления перемещения
		if (dy > 0) {
			let di = -1;
			let i = gridSize - 1;
		} 
		else {
			let di = 1;
			let i = 0;
		}

		if (dx > 0) {
			let dj = -1;
			let j = gridSize - 1;
		} 
		else {
			let dj = 1;
			let j = 0;
		}

		while (p > 0)
		{
			if (dy > 0) {
				let i = gridSize - 1;
			} else {
				let i = 0;
			}

			if (dx > 0) {
				let j = gridSize - 1;
			} else {
				let j = 0;
			}

			// теперь проходим по клеткам
			while ((dy = 0 and j >= 0 and j < gridSize) or (dx = 0 and i >= 0 and i < gridSize))
			{
				let tempArr = cells[i];
				let boolArr = isFusionCells[i];
				let ni = i - dy;
				let nj = j - dx;

				if (ni >= 0 & ni < gridSize & nj >= 0 & nj < gridSize)
				{
					let tempArr1 = cells[ni];
					let boolArr1 = isFusionCells[ni];

					if (tempArr[j] = tempArr1[nj] & (~(tempArr[j] = 0)) & boolArr[j] & boolArr1[nj])
					{
						do Screen.setColor(false);
						do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5, gridSize);
						do DrawerNum.drawNum(tempArr1[nj], x1 + (((x2 - x1) / gridSize) * nj) + 5, y1 + (((x2 - x1) / gridSize) * ni) + 5, gridSize);
						let tempArr[j] = tempArr[j] + tempArr1[nj];
						if (tempArr[j] = 2048) {
							let isWin = true;
						}
						let tempArr1[nj] = 0;
						let boolArr[j] = false;
						let addNewTile = true;
						do Screen.setColor(true);
						do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5, gridSize);
					}
					else {
						if (tempArr[j] = 0 & (~(tempArr1[nj] = 0)))
						{
							do Screen.setColor(false);
							do DrawerNum.drawNum(tempArr1[nj], x1 + (((x2 - x1) / gridSize) * nj) + 5, y1 + (((x2 - x1) / gridSize) * ni) + 5, gridSize);
							let tempArr[j] = tempArr1[nj];
							let tempArr1[nj] = 0;
							let addNewTile = true;
							do Screen.setColor(true);
							do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5, gridSize);
						}
					}
				}

				if (dy > 0) {
					let i = i - 1;
				} 
				else {
					if (dy < 0) {
						let i = i + 1;
					}
				}

				if (dx > 0) {
					let j = j - 1;
				} 
				else {
					if (dx < 0) {
						let j = j + 1;
					}
				}
			}

			let p = p - 1;
		}

		if (addNewTile) {
			do addRandomTile();
		}

		return;
	}


    method void moveRight() { 
		do moveInDirection(1, 0);
		return;
		}
    method void moveLeft() { 
		do moveInDirection(-1, 0);
		return;
		}
    method void moveUp() { 
		do moveInDirection(0, -1);
		return;
		}
    method void moveDown() { 
		do moveInDirection(0, 1);
		return;
		}


	method void addRandomTile() 
	{
        var int i, j, index, value, emptyCount;
        var Array emptyCells;
        var Array tempArr;

        // Подсчет пустых ячеек
		let emptyCells = Array.new(50);
        let i = 0;
		let index = 0;

        while (i < gridSize) {
            let tempArr = cells[i];
            let j = 0;
            while (j < gridSize) {
                if (tempArr[j] = 0) {
					let emptyCount = emptyCount + 1;
                    let emptyCells[index] = i;
					let emptyCells[index+1] = j;
					let index = index + 2;
                }
                let j = j + 1;
            }
            let i = i + 1;
        }

        // Выбираем случайную пустую ячейку
        let index = Random.randomEven(index, score);
        let i = emptyCells[index];
        let j = emptyCells[index + 1];
		
		// Выбираем случайное число 2 или 4
		let value = Random.randomTwoOrFour(emptyCount, score);
        let tempArr = cells[i];
        let tempArr[j] = value;
		do setScore(value);

        // Отрисовываем новую плитку
        do DrawerNum.drawNum(value, x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5, gridSize);

		do emptyCells.dispose();
		return;
    }

	method boolean isGameOver() 
	{
		var int i, j;
		var Array tempArr, tempArr1;

		// Проверяем, есть ли пустые клетки
		let i = 0;
		let j = 0;
		while (i < gridSize) {
			let tempArr = cells[i]; // Объявляем tempArr для каждой строки
			while (j < gridSize) {
				if (tempArr[j] = 0) {
					return false;  // Есть пустая клетка, игра продолжается
				}
				let j = j + 1;
			}
			let i = i + 1;
			let j = 0;
		}

		while (i < gridSize) {
			let tempArr = cells[i]; // Объявляем tempArr для каждой строки
			while (j < gridSize) {
				if (tempArr[j] = 0) {
					return false;  // Есть пустая клетка, игра продолжается
				}
				let j = j + 1;
			}
			let i = i + 1;
			let j = 0;
		}

		// Проверяем, можно ли сделать слияние плиток по горизонтали
		let i = 0;
		let j = 0;
		while (i < gridSize) {
			let tempArr = cells[i];  // Объявляем tempArr для каждой строки
			while (j < (gridSize - 1)) {
				if (tempArr[j] = tempArr[j+1]) {
					return false;  // Можно объединить плитки по горизонтали
				}
				let j = j + 1;
			}
			let i = i + 1;
			let j = 0;
		}

		// Проверяем, можно ли сделать слияние плиток по вертикали
		let i = 0;
		let j = 0;
		while (j < gridSize) {
			while (i < (gridSize - 1)) {
				let tempArr = cells[i];
				let tempArr1 = cells[i+1]; // Объявляем tempArr1 для соседних строк
				if (tempArr[j] = tempArr1[j]) {
					return false;  // Можно объединить плитки по вертикали
				}
				let i = i + 1;
			}
			let i = 0;
			let j = j + 1;
		}

		// Если не осталось пустых клеток и плитки не могут быть объединены
		return true;  // Игра закончена
	}

}
