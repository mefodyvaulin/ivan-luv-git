class GameFiled 
{

	static int score;
	static int x1;
	static int y1;
	static int x2;
	static int y2;
    field int gridSize; // счетчик, размер сетки
	static Array tiels; // двумерный массив
	

	constructor GameFiled new(int count, int size) {
		var int i, j;
		var Array tempArr;
		let score = count;
		let gridSize = size;
		
		let x1 = 136;
		let y1 = 8;
		let x2 = (136 + 240);
		let y2 = (8 + 240);

		//инициализируется двумерный массив соответствующий игровому полю
		let tiels = Array.new(size);
		let i = 0;
		let j = 0;
		while (i < size){
			let tiels[i] = Array.new(size);
			while (j < size){
				let tempArr = tiels[i];
				let tempArr[j] = 0;
				let j = j + 1;
			}
			let j = 0;
			let i = i + 1;
		}
		
		do Screen.setColor(true);
		// рисуется игрове поле
		do GameFiled.draw(size);
		
		// выводится счет
		do GameFiled.setScore(0);

		return this;
	}

	method int getSize() {
        return gridSize; // Доступ к полю вне класса
    }


	function void setScore(int bonus){
		let score = score + bonus;
		do Output.moveCursor(1, 1);
		do Output.printString("Score:");
		do Output.printInt(score);
		return;
	}

	method void dispose() {
		do Memory.deAlloc(this);
		return;
	}

	/*Рисует игровую сетку */
	function void draw(int gridSiz) {
		var int tileSize;
		var int i;
		var int j;
		var Array tempArr;

		let tileSize = 240 / gridSiz; // Размер плитки в зависимости от количества плиток

		// Вертикальные линии
		let i = 0;
		while (i < (gridSiz + 1)) {
			do Screen.drawLine(x1 + (i * tileSize), y1, x1 + (i * tileSize), y2); 
			let i = i + 1;
		}

		// Горизонтальные линии
		let j = 0;
		while (j < (gridSiz + 1)) {
			do Screen.drawLine(x1, y1 + (j * tileSize), x2, y1 + (j * tileSize)); 
			let j = j + 1;
		}

		
		//начальные ячейки
		
		let tempArr = tiels[0]; //1 строка

		do DrawerNum.drawNum(2, (x1 + 5), (y1 + 5));
		let tempArr[0] = 2;
		do GameFiled.setScore(2);

		do DrawerNum.drawNum(2, (x1 + 5)+ tileSize, (y1 + 5 ));
		let tempArr[1] = 2;
		do GameFiled.setScore(2);

		do DrawerNum.drawNum(2, (x1 + 5)+(tileSize * 2), (y1 + 5));
		let tempArr[2] = 2;
		do GameFiled.setScore(2);

		let tempArr = tiels[1]; // 2 строка

		do DrawerNum.drawNum(2, (x1 + 5), (y1 + 5) + tileSize);
		let tempArr[0] = 2;
		do GameFiled.setScore(2);

		do DrawerNum.drawNum(2, (x1 + 5) + tileSize, (y1 + 5 + tileSize));
		let tempArr[1] = 2;
		do GameFiled.setScore(2);

		do DrawerNum.drawNum(2, (x1 + 5) + (tileSize * 2), (y1 + 5 + tileSize));
		let tempArr[2] = 2;
		do GameFiled.setScore(2);
/*
		let tempArr = tiels[2]; // 3 строка

		do DrawerNum.drawNum(2, (x1 + 5), (y1 + 5)+ (tileSize * 2));
		let tempArr[0] = 2;
		do GameFiled.setScore(2);

		do DrawerNum.drawNum(2, (x1 + 5) + tileSize,  y1 + 5 + (tileSize * 2));
		let tempArr[1] = 2;
		do GameFiled.setScore(2);

		do DrawerNum.drawNum(2, (x1 + 5) + (tileSize * 2), (y1 + 5 + (tileSize * 2)));
		let tempArr[2] = 2;
		do GameFiled.setScore(2);
*/
		return;
	}

	method void moveRight(){
		var Array tempArr;
		var int i, j;

		let i = 0;
		let j = gridSize - 1;
		while (i < gridSize)
		{
			let tempArr = tiels[i]; 
			while (j > 0)
			{
				if (tempArr[j] = tempArr[j-1] & (~(tempArr[j] = 0)))
				{
					
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					do DrawerNum.drawNum(tempArr[j-1], x1 + (((x2 - x1) / gridSize) * (j-1)) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					let tempArr[j] = tempArr[j] + tempArr[j-1];
					let tempArr[j-1] = 0;
                	do GameFiled.setScore(tempArr[j]);  // Добавляем очки
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				if (tempArr[j] = 0 & (~(tempArr[j-1] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j-1], x1 + (((x2 - x1) / gridSize) * (j-1)) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					let tempArr[j] = tempArr[j-1];
					let tempArr[j-1] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let j = j - 1;
			}
			let j = gridSize - 1;
			let i = i + 1;
		}
		
		let i = 0;
		let j = gridSize - 1;
		while (i < gridSize)
		{
			let tempArr = tiels[i]; 
			while (j > 0)
			{
				if (tempArr[j] = 0 & (~(tempArr[j-1] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j-1], x1 + (((x2 - x1) / gridSize) * (j-1)) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					let tempArr[j] = tempArr[j-1];
					let tempArr[j-1] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let j = j - 1;
			}
			let j = gridSize - 1;
			let i = i + 1;
		}
		do addRandomTile();
		return;
	}

	method void moveLeft(){
		var Array tempArr;
		var int i, j;

		let i = 0;
		let j = 0;
		while (i < gridSize)
		{
			let tempArr = tiels[i]; 
			while (j < (gridSize - 1))
			{
				if (tempArr[j] = tempArr[j+1] & (~(tempArr[j] = 0)))
				{
					
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					do DrawerNum.drawNum(tempArr[j+1], x1 + (((x2 - x1) / gridSize) * (j+1)) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					let tempArr[j] = tempArr[j] + tempArr[j+1];
					let tempArr[j+1] = 0;
					do GameFiled.setScore(tempArr[j]);  // Добавляем очки
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				if (tempArr[j] = 0 & (~(tempArr[j+1] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j+1], x1 + (((x2 - x1) / gridSize) * (j+1)) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					let tempArr[j] = tempArr[j+1];
					let tempArr[j+1] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j],x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let j = j + 1;
			}
			let j = 0;
			let i = i + 1;
		}
		let i = 0;
		let j = 0;
		while (i < gridSize)
		{
			let tempArr = tiels[i]; 
			while (j < (gridSize - 1))
			{
				if (tempArr[j] = 0 & (~(tempArr[j+1] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j+1], x1 + (((x2 - x1) / gridSize) * (j+1)) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					let tempArr[j] = tempArr[j+1];
					let tempArr[j+1] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j],x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let j = j + 1;
			}
			let j = 0;
			let i = i + 1;
		}
		do addRandomTile();
		return;
	}

	method void moveUp(){
		var Array tempArr;
		var Array tempArr1;
		var int i, j;

		let i = 0;
		let j = 0;
		while (j < gridSize )
		{
			while (i < (gridSize - 1))
			{
				let tempArr = tiels[i];
				let tempArr1 = tiels[i+1];
				if (tempArr[j] = tempArr1[j] & (~(tempArr[j] = 0)))
				{
					
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					do DrawerNum.drawNum(tempArr1[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * (i+1)) + 5);
					let tempArr[j] = tempArr1[j] + tempArr[j];
					let tempArr1[j] = 0;
					do GameFiled.setScore(tempArr[j]);  // Добавляем очки
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				if (tempArr[j] = 0 & (~(tempArr1[j] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr1[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * (i+1)) + 5);
					let tempArr[j] = tempArr1[j];
					let tempArr1[j] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let i = i + 1;
			}
			let i = 0;
			let j = j + 1;
		}
		let i = 0;
		let j = 0;
		while (j < gridSize )
		{
			while (i < (gridSize - 1))
			{
				let tempArr = tiels[i];
				let tempArr1 = tiels[i+1];
				
				if (tempArr[j] = 0 & (~(tempArr1[j] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr1[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * (i+1)) + 5);
					let tempArr[j] = tempArr1[j];
					let tempArr1[j] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let i = i + 1;
			}
			let i = 0;
			let j = j + 1;
		}
		do addRandomTile();
		return;
	}

	method void moveDown(){
		var Array tempArr;
		var Array tempArr1;
		var int i, j;

		let i = gridSize - 1;
		let j = 0;
		while (j < gridSize)
		{
			while (i > 0)
			{
				let tempArr = tiels[i];
				let tempArr1 = tiels[i-1];
				if (tempArr[j] = tempArr1[j] & (~(tempArr[j] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
					do DrawerNum.drawNum(tempArr1[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * (i-1)) + 5);
					let tempArr[j] = tempArr1[j] + tempArr[j];
					let tempArr1[j] = 0;
					do GameFiled.setScore(tempArr[j]);  // Добавляем очки
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				if (tempArr[j] = 0 & (~(tempArr1[j] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr1[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * (i-1)) + 5);
					let tempArr[j] = tempArr1[j];
					let tempArr1[j] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let i = i - 1;
			}
			let i = gridSize - 1;
			let j = j + 1;
		}
		let i = gridSize - 1;
		let j = 0;
		while (j < gridSize)
		{
			while (i > 0)
			{
				let tempArr = tiels[i];
				let tempArr1 = tiels[i-1];
				
				if (tempArr[j] = 0 & (~(tempArr1[j] = 0)))
				{
					do Screen.setColor(false);
					do DrawerNum.drawNum(tempArr1[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * (i-1)) + 5);
					let tempArr[j] = tempArr1[j];
					let tempArr1[j] = 0;
					do Screen.setColor(true);
					do DrawerNum.drawNum(tempArr[j], x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
				}

				let i = i - 1;
			}
			let i = gridSize - 1;
			let j = j + 1;
		}
		do addRandomTile();
		return;
	}

	method void addRandomTile() {
        var int emptyCount, i, j, index, value;
        var Array emptyCells;
        var Array tempArr;

        // Подсчет пустых ячеек
        let emptyCount = 0;
        let i = 0;
        while (i < gridSize) {
            let tempArr = tiels[i];
            let j = 0;
            while (j < gridSize) {
                if (tempArr[j] = 0) {
                    let emptyCount = emptyCount + 1;
                }
                let j = j + 1;
            }
            let i = i + 1;
        }

        // Если нет пустых ячеек, выходим
        if (emptyCount = 0) {
            return;
        }

        // Создаем массив для хранения координат пустых ячеек
        let emptyCells = Array.new(emptyCount * 2);
        let i = 0;
        let j = 0;
        let index = 0;

        // Заполняем массив координатами пустых ячеек
        while (i < gridSize) {
            let tempArr = tiels[i];
            let j = 0;
            while (j < gridSize) {
                if (tempArr[j] = 0) {
                    let emptyCells[index] = i; // строка
                    let emptyCells[index + 1] = j; // столбец
                    let index = index + 2;
                }
                let j = j + 1;
            }
            let i = i + 1;
        }

        // Выбираем случайную пустую ячейку
        let index = Utils.random(emptyCount) * 2;
        let i = emptyCells[index];
        let j = emptyCells[index + 1];

        // Генерируем новое число (2 или 4)
        let value = Utils.random(2) * 2 + 2;

        // Устанавливаем новое значение в ячейку
        let tempArr = tiels[i];
        let tempArr[j] = value;

        // Отрисовываем новую плитку
        do DrawerNum.drawNum(value, x1 + (((x2 - x1) / gridSize) * j) + 5, y1 + (((x2 - x1) / gridSize) * i) + 5);
		return;
    }

	method bool isGameOver() {
		var int i, j;
		var Array tempArr, tempArr1;

		// Проверяем, есть ли пустые клетки
		let i = 0;
		let j = 0;
		while (i < gridSize) {
			let tempArr = tiels[i]; // Объявляем tempArr для каждой строки
			while (j < gridSize) {
				if (tempArr[j] = 0) {
					return false;  // Есть пустая клетка, игра продолжается
				}
				let j = j + 1;
			}
			let i = i + 1;
			let j = 0;
		}

		// Проверяем, можно ли сделать слияние плиток по горизонтали
		let i = 0;
		let j = 0;
		while (i < gridSize) {
			let tempArr = tiels[i];  // Объявляем tempArr для каждой строки
			while (j < (gridSize - 1)) {
				if (tempArr[j] = tempArr[j+1]) {
					return false;  // Можно объединить плитки по горизонтали
				}
				let j = j + 1;
			}
			let i = i + 1;
			let j = 0;
		}

		// Проверяем, можно ли сделать слияние плиток по вертикали
		let i = 0;
		let j = 0;
		while (j < gridSize) {
			while (i < (gridSize - 1)) {
				let tempArr = tiels[i];
				let tempArr1 = tiels[i+1]; // Объявляем tempArr1 для соседних строк
				if (tempArr[j] = tempArr1[j]) {
					return false;  // Можно объединить плитки по вертикали
				}
				let i = i + 1;
			}
			let i = 0;
			let j = j + 1;
		}

		// Если не осталось пустых клеток и плитки не могут быть объединены
		return true;  // Игра закончена
	}

}